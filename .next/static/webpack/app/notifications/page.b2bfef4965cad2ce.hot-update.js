"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/notifications/page",{

/***/ "(app-pages-browser)/./lib/api-client.ts":
/*!***************************!*\
  !*** ./lib/api-client.ts ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ApiClient: function() { return /* binding */ ApiClient; }\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n/**\n * Production-ready API client with error handling, retries, and caching\n */ class ApiClient {\n    async makeRequest(endpoint) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        const { method = \"GET\", headers = {}, body, timeout = this.timeout, retries = this.retries } = options;\n        const url = \"\".concat(this.baseURL).concat(endpoint);\n        const cacheKey = \"\".concat(method, \":\").concat(url, \":\").concat(JSON.stringify(body || {}));\n        // Check cache for GET requests\n        if (method === \"GET\") {\n            const cached = this.cache.get(cacheKey);\n            if (cached && Date.now() - cached.timestamp < this.cacheTTL) {\n                return cached.data;\n            }\n        }\n        const controller = new AbortController();\n        const timeoutId = setTimeout(()=>controller.abort(), timeout);\n        try {\n            const response = await fetch(url, {\n                method,\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...headers\n                },\n                body: body ? JSON.stringify(body) : undefined,\n                signal: controller.signal\n            });\n            clearTimeout(timeoutId);\n            if (!response.ok) {\n                throw new Error(\"HTTP \".concat(response.status, \": \").concat(response.statusText));\n            }\n            const data = await response.json();\n            // Cache successful GET requests\n            if (method === \"GET\") {\n                this.cache.set(cacheKey, {\n                    data,\n                    timestamp: Date.now()\n                });\n            }\n            return data;\n        } catch (error) {\n            clearTimeout(timeoutId);\n            if (retries > 0 && this.shouldRetry(error)) {\n                await this.delay(this.retryDelay);\n                return this.makeRequest(endpoint, {\n                    ...options,\n                    retries: retries - 1\n                });\n            }\n            throw error;\n        }\n    }\n    shouldRetry(error) {\n        var _error_message, _error_message1;\n        if (error.name === \"AbortError\") return false;\n        if ((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes(\"HTTP 4\")) return false // Don't retry client errors\n        ;\n        if ((_error_message1 = error.message) === null || _error_message1 === void 0 ? void 0 : _error_message1.includes(\"HTTP 5\")) return true // Retry server errors\n        ;\n        return true;\n    }\n    delay(ms) {\n        return new Promise((resolve)=>setTimeout(resolve, ms));\n    }\n    // Public methods\n    async get(endpoint, options) {\n        return this.makeRequest(endpoint, {\n            ...options,\n            method: \"GET\"\n        });\n    }\n    async post(endpoint, body, options) {\n        return this.makeRequest(endpoint, {\n            ...options,\n            method: \"POST\",\n            body\n        });\n    }\n    async put(endpoint, body, options) {\n        return this.makeRequest(endpoint, {\n            ...options,\n            method: \"PUT\",\n            body\n        });\n    }\n    async delete(endpoint, options) {\n        return this.makeRequest(endpoint, {\n            ...options,\n            method: \"DELETE\"\n        });\n    }\n    async patch(endpoint, body, options) {\n        return this.makeRequest(endpoint, {\n            ...options,\n            method: \"PATCH\",\n            body\n        });\n    }\n    // Clear cache\n    clearCache() {\n        this.cache.clear();\n    }\n    // Set cache TTL\n    setCacheTTL(ttl) {\n        this.cacheTTL = ttl;\n    }\n    constructor(config){\n        this.cache = new Map();\n        this.cacheTTL = 5 * 60 * 1000 // 5 minutes\n        ;\n        this.baseURL = config.baseURL;\n        this.timeout = config.timeout || 10000;\n        this.retries = config.retries || 3;\n        this.retryDelay = config.retryDelay || 1000;\n    }\n}\n// Create singleton instance\nconst apiClient = new ApiClient({\n    baseURL: process.env.NEXT_PUBLIC_API_URL || \"http://localhost:3001/api/v1\",\n    timeout: 10000,\n    retries: 3,\n    retryDelay: 1000\n});\n// Add authentication methods to the client\napiClient.login = async (email, password)=>{\n    return apiClient.post(\"/auth/login\", {\n        email,\n        password\n    });\n};\napiClient.register = async (userData)=>{\n    return apiClient.post(\"/auth/register\", userData);\n};\napiClient.logout = async ()=>{\n    return apiClient.post(\"/auth/logout\");\n};\napiClient.getCurrentUser = async ()=>{\n    return apiClient.get(\"/auth/me\");\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (apiClient);\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9hcGktY2xpZW50LnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7O0NBRUMsR0FpQkQsTUFBTUE7SUFlSixNQUFjQyxZQUNaQyxRQUFnQixFQUVKO1lBRFpDLFVBQUFBLGlFQUEwQixDQUFDO1FBRTNCLE1BQU0sRUFDSkMsU0FBUyxLQUFLLEVBQ2RDLFVBQVUsQ0FBQyxDQUFDLEVBQ1pDLElBQUksRUFDSkMsVUFBVSxJQUFJLENBQUNBLE9BQU8sRUFDdEJDLFVBQVUsSUFBSSxDQUFDQSxPQUFPLEVBQ3ZCLEdBQUdMO1FBRUosTUFBTU0sTUFBTSxHQUFrQlAsT0FBZixJQUFJLENBQUNRLE9BQU8sRUFBWSxPQUFUUjtRQUM5QixNQUFNUyxXQUFXLEdBQWFGLE9BQVZMLFFBQU8sS0FBVVEsT0FBUEgsS0FBSSxLQUE4QixPQUEzQkcsS0FBS0MsU0FBUyxDQUFDUCxRQUFRLENBQUM7UUFFN0QsK0JBQStCO1FBQy9CLElBQUlGLFdBQVcsT0FBTztZQUNwQixNQUFNVSxTQUFTLElBQUksQ0FBQ0MsS0FBSyxDQUFDQyxHQUFHLENBQUNMO1lBQzlCLElBQUlHLFVBQVVHLEtBQUtDLEdBQUcsS0FBS0osT0FBT0ssU0FBUyxHQUFHLElBQUksQ0FBQ0MsUUFBUSxFQUFFO2dCQUMzRCxPQUFPTixPQUFPTyxJQUFJO1lBQ3BCO1FBQ0Y7UUFFQSxNQUFNQyxhQUFhLElBQUlDO1FBQ3ZCLE1BQU1DLFlBQVlDLFdBQVcsSUFBTUgsV0FBV0ksS0FBSyxJQUFJbkI7UUFFdkQsSUFBSTtZQUNGLE1BQU1vQixXQUFXLE1BQU1DLE1BQU1uQixLQUFLO2dCQUNoQ0w7Z0JBQ0FDLFNBQVM7b0JBQ1AsZ0JBQWdCO29CQUNoQixHQUFHQSxPQUFPO2dCQUNaO2dCQUNBQyxNQUFNQSxPQUFPTSxLQUFLQyxTQUFTLENBQUNQLFFBQVF1QjtnQkFDcENDLFFBQVFSLFdBQVdRLE1BQU07WUFDM0I7WUFFQUMsYUFBYVA7WUFFYixJQUFJLENBQUNHLFNBQVNLLEVBQUUsRUFBRTtnQkFDaEIsTUFBTSxJQUFJQyxNQUFNLFFBQTRCTixPQUFwQkEsU0FBU08sTUFBTSxFQUFDLE1BQXdCLE9BQXBCUCxTQUFTUSxVQUFVO1lBQ2pFO1lBRUEsTUFBTWQsT0FBTyxNQUFNTSxTQUFTUyxJQUFJO1lBRWhDLGdDQUFnQztZQUNoQyxJQUFJaEMsV0FBVyxPQUFPO2dCQUNwQixJQUFJLENBQUNXLEtBQUssQ0FBQ3NCLEdBQUcsQ0FBQzFCLFVBQVU7b0JBQ3ZCVTtvQkFDQUYsV0FBV0YsS0FBS0MsR0FBRztnQkFDckI7WUFDRjtZQUVBLE9BQU9HO1FBQ1QsRUFBRSxPQUFPaUIsT0FBTztZQUNkUCxhQUFhUDtZQUViLElBQUloQixVQUFVLEtBQUssSUFBSSxDQUFDK0IsV0FBVyxDQUFDRCxRQUFRO2dCQUMxQyxNQUFNLElBQUksQ0FBQ0UsS0FBSyxDQUFDLElBQUksQ0FBQ0MsVUFBVTtnQkFDaEMsT0FBTyxJQUFJLENBQUN4QyxXQUFXLENBQUNDLFVBQVU7b0JBQ2hDLEdBQUdDLE9BQU87b0JBQ1ZLLFNBQVNBLFVBQVU7Z0JBQ3JCO1lBQ0Y7WUFFQSxNQUFNOEI7UUFDUjtJQUNGO0lBRVFDLFlBQVlELEtBQVUsRUFBVztZQUVuQ0EsZ0JBQ0FBO1FBRkosSUFBSUEsTUFBTUksSUFBSSxLQUFLLGNBQWMsT0FBTztRQUN4QyxLQUFJSixpQkFBQUEsTUFBTUssT0FBTyxjQUFiTCxxQ0FBQUEsZUFBZU0sUUFBUSxDQUFDLFdBQVcsT0FBTyxNQUFNLDRCQUE0Qjs7UUFDaEYsS0FBSU4sa0JBQUFBLE1BQU1LLE9BQU8sY0FBYkwsc0NBQUFBLGdCQUFlTSxRQUFRLENBQUMsV0FBVyxPQUFPLEtBQUssc0JBQXNCOztRQUN6RSxPQUFPO0lBQ1Q7SUFFUUosTUFBTUssRUFBVSxFQUFpQjtRQUN2QyxPQUFPLElBQUlDLFFBQVFDLENBQUFBLFVBQVd0QixXQUFXc0IsU0FBU0Y7SUFDcEQ7SUFFQSxpQkFBaUI7SUFDakIsTUFBTTdCLElBQU9kLFFBQWdCLEVBQUVDLE9BQXdCLEVBQWM7UUFDbkUsT0FBTyxJQUFJLENBQUNGLFdBQVcsQ0FBSUMsVUFBVTtZQUFFLEdBQUdDLE9BQU87WUFBRUMsUUFBUTtRQUFNO0lBQ25FO0lBRUEsTUFBTTRDLEtBQVE5QyxRQUFnQixFQUFFSSxJQUFVLEVBQUVILE9BQXdCLEVBQWM7UUFDaEYsT0FBTyxJQUFJLENBQUNGLFdBQVcsQ0FBSUMsVUFBVTtZQUFFLEdBQUdDLE9BQU87WUFBRUMsUUFBUTtZQUFRRTtRQUFLO0lBQzFFO0lBRUEsTUFBTTJDLElBQU8vQyxRQUFnQixFQUFFSSxJQUFVLEVBQUVILE9BQXdCLEVBQWM7UUFDL0UsT0FBTyxJQUFJLENBQUNGLFdBQVcsQ0FBSUMsVUFBVTtZQUFFLEdBQUdDLE9BQU87WUFBRUMsUUFBUTtZQUFPRTtRQUFLO0lBQ3pFO0lBRUEsTUFBTTRDLE9BQVVoRCxRQUFnQixFQUFFQyxPQUF3QixFQUFjO1FBQ3RFLE9BQU8sSUFBSSxDQUFDRixXQUFXLENBQUlDLFVBQVU7WUFBRSxHQUFHQyxPQUFPO1lBQUVDLFFBQVE7UUFBUztJQUN0RTtJQUVBLE1BQU0rQyxNQUFTakQsUUFBZ0IsRUFBRUksSUFBVSxFQUFFSCxPQUF3QixFQUFjO1FBQ2pGLE9BQU8sSUFBSSxDQUFDRixXQUFXLENBQUlDLFVBQVU7WUFBRSxHQUFHQyxPQUFPO1lBQUVDLFFBQVE7WUFBU0U7UUFBSztJQUMzRTtJQUVBLGNBQWM7SUFDZDhDLGFBQW1CO1FBQ2pCLElBQUksQ0FBQ3JDLEtBQUssQ0FBQ3NDLEtBQUs7SUFDbEI7SUFFQSxnQkFBZ0I7SUFDaEJDLFlBQVlDLEdBQVcsRUFBUTtRQUM3QixJQUFJLENBQUNuQyxRQUFRLEdBQUdtQztJQUNsQjtJQXBIQUMsWUFBWUMsTUFBdUIsQ0FBRTthQUg3QjFDLFFBQXVELElBQUkyQzthQUMzRHRDLFdBQW1CLElBQUksS0FBSyxLQUFLLFlBQVk7O1FBR25ELElBQUksQ0FBQ1YsT0FBTyxHQUFHK0MsT0FBTy9DLE9BQU87UUFDN0IsSUFBSSxDQUFDSCxPQUFPLEdBQUdrRCxPQUFPbEQsT0FBTyxJQUFJO1FBQ2pDLElBQUksQ0FBQ0MsT0FBTyxHQUFHaUQsT0FBT2pELE9BQU8sSUFBSTtRQUNqQyxJQUFJLENBQUNpQyxVQUFVLEdBQUdnQixPQUFPaEIsVUFBVSxJQUFJO0lBQ3pDO0FBZ0hGO0FBbUJBLDRCQUE0QjtBQUM1QixNQUFNa0IsWUFBWSxJQUFJM0QsVUFBVTtJQUM5QlUsU0FBU2tELE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0MsbUJBQW1CLElBQUk7SUFDNUN2RCxTQUFTO0lBQ1RDLFNBQVM7SUFDVGlDLFlBQVk7QUFDZDtBQUVBLDJDQUEyQztBQUMzQ2tCLFVBQVVJLEtBQUssR0FBRyxPQUFPQyxPQUFlQztJQUN0QyxPQUFPTixVQUFVWCxJQUFJLENBQUMsZUFBZTtRQUFFZ0I7UUFBT0M7SUFBUztBQUN6RDtBQUVBTixVQUFVTyxRQUFRLEdBQUcsT0FBT0M7SUFDMUIsT0FBT1IsVUFBVVgsSUFBSSxDQUFDLGtCQUFrQm1CO0FBQzFDO0FBRUFSLFVBQVVTLE1BQU0sR0FBRztJQUNqQixPQUFPVCxVQUFVWCxJQUFJLENBQUM7QUFDeEI7QUFFQVcsVUFBVVUsY0FBYyxHQUFHO0lBQ3pCLE9BQU9WLFVBQVUzQyxHQUFHLENBQUM7QUFDdkI7QUFFQSwrREFBZTJDLFNBQVNBLEVBQUE7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvYXBpLWNsaWVudC50cz9iMDk5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUHJvZHVjdGlvbi1yZWFkeSBBUEkgY2xpZW50IHdpdGggZXJyb3IgaGFuZGxpbmcsIHJldHJpZXMsIGFuZCBjYWNoaW5nXG4gKi9cblxuaW50ZXJmYWNlIEFwaUNsaWVudENvbmZpZyB7XG4gIGJhc2VVUkw6IHN0cmluZ1xuICB0aW1lb3V0PzogbnVtYmVyXG4gIHJldHJpZXM/OiBudW1iZXJcbiAgcmV0cnlEZWxheT86IG51bWJlclxufVxuXG5pbnRlcmZhY2UgUmVxdWVzdE9wdGlvbnMge1xuICBtZXRob2Q/OiAnR0VUJyB8ICdQT1NUJyB8ICdQVVQnIHwgJ0RFTEVURScgfCAnUEFUQ0gnXG4gIGhlYWRlcnM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG4gIGJvZHk/OiBhbnlcbiAgdGltZW91dD86IG51bWJlclxuICByZXRyaWVzPzogbnVtYmVyXG59XG5cbmNsYXNzIEFwaUNsaWVudCB7XG4gIHByaXZhdGUgYmFzZVVSTDogc3RyaW5nXG4gIHByaXZhdGUgdGltZW91dDogbnVtYmVyXG4gIHByaXZhdGUgcmV0cmllczogbnVtYmVyXG4gIHByaXZhdGUgcmV0cnlEZWxheTogbnVtYmVyXG4gIHByaXZhdGUgY2FjaGU6IE1hcDxzdHJpbmcsIHsgZGF0YTogYW55OyB0aW1lc3RhbXA6IG51bWJlciB9PiA9IG5ldyBNYXAoKVxuICBwcml2YXRlIGNhY2hlVFRMOiBudW1iZXIgPSA1ICogNjAgKiAxMDAwIC8vIDUgbWludXRlc1xuXG4gIGNvbnN0cnVjdG9yKGNvbmZpZzogQXBpQ2xpZW50Q29uZmlnKSB7XG4gICAgdGhpcy5iYXNlVVJMID0gY29uZmlnLmJhc2VVUkxcbiAgICB0aGlzLnRpbWVvdXQgPSBjb25maWcudGltZW91dCB8fCAxMDAwMFxuICAgIHRoaXMucmV0cmllcyA9IGNvbmZpZy5yZXRyaWVzIHx8IDNcbiAgICB0aGlzLnJldHJ5RGVsYXkgPSBjb25maWcucmV0cnlEZWxheSB8fCAxMDAwXG4gIH1cblxuICBwcml2YXRlIGFzeW5jIG1ha2VSZXF1ZXN0PFQ+KFxuICAgIGVuZHBvaW50OiBzdHJpbmcsXG4gICAgb3B0aW9uczogUmVxdWVzdE9wdGlvbnMgPSB7fVxuICApOiBQcm9taXNlPFQ+IHtcbiAgICBjb25zdCB7XG4gICAgICBtZXRob2QgPSAnR0VUJyxcbiAgICAgIGhlYWRlcnMgPSB7fSxcbiAgICAgIGJvZHksXG4gICAgICB0aW1lb3V0ID0gdGhpcy50aW1lb3V0LFxuICAgICAgcmV0cmllcyA9IHRoaXMucmV0cmllc1xuICAgIH0gPSBvcHRpb25zXG5cbiAgICBjb25zdCB1cmwgPSBgJHt0aGlzLmJhc2VVUkx9JHtlbmRwb2ludH1gXG4gICAgY29uc3QgY2FjaGVLZXkgPSBgJHttZXRob2R9OiR7dXJsfToke0pTT04uc3RyaW5naWZ5KGJvZHkgfHwge30pfWBcblxuICAgIC8vIENoZWNrIGNhY2hlIGZvciBHRVQgcmVxdWVzdHNcbiAgICBpZiAobWV0aG9kID09PSAnR0VUJykge1xuICAgICAgY29uc3QgY2FjaGVkID0gdGhpcy5jYWNoZS5nZXQoY2FjaGVLZXkpXG4gICAgICBpZiAoY2FjaGVkICYmIERhdGUubm93KCkgLSBjYWNoZWQudGltZXN0YW1wIDwgdGhpcy5jYWNoZVRUTCkge1xuICAgICAgICByZXR1cm4gY2FjaGVkLmRhdGFcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpXG4gICAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiBjb250cm9sbGVyLmFib3J0KCksIHRpbWVvdXQpXG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAuLi5oZWFkZXJzXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IGJvZHkgPyBKU09OLnN0cmluZ2lmeShib2R5KSA6IHVuZGVmaW5lZCxcbiAgICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbFxuICAgICAgfSlcblxuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZClcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9OiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YClcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuXG4gICAgICAvLyBDYWNoZSBzdWNjZXNzZnVsIEdFVCByZXF1ZXN0c1xuICAgICAgaWYgKG1ldGhvZCA9PT0gJ0dFVCcpIHtcbiAgICAgICAgdGhpcy5jYWNoZS5zZXQoY2FjaGVLZXksIHtcbiAgICAgICAgICBkYXRhLFxuICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKVxuXG4gICAgICBpZiAocmV0cmllcyA+IDAgJiYgdGhpcy5zaG91bGRSZXRyeShlcnJvcikpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5kZWxheSh0aGlzLnJldHJ5RGVsYXkpXG4gICAgICAgIHJldHVybiB0aGlzLm1ha2VSZXF1ZXN0KGVuZHBvaW50LCB7XG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICByZXRyaWVzOiByZXRyaWVzIC0gMVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc2hvdWxkUmV0cnkoZXJyb3I6IGFueSk6IGJvb2xlYW4ge1xuICAgIGlmIChlcnJvci5uYW1lID09PSAnQWJvcnRFcnJvcicpIHJldHVybiBmYWxzZVxuICAgIGlmIChlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygnSFRUUCA0JykpIHJldHVybiBmYWxzZSAvLyBEb24ndCByZXRyeSBjbGllbnQgZXJyb3JzXG4gICAgaWYgKGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKCdIVFRQIDUnKSkgcmV0dXJuIHRydWUgLy8gUmV0cnkgc2VydmVyIGVycm9yc1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBwcml2YXRlIGRlbGF5KG1zOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSlcbiAgfVxuXG4gIC8vIFB1YmxpYyBtZXRob2RzXG4gIGFzeW5jIGdldDxUPihlbmRwb2ludDogc3RyaW5nLCBvcHRpb25zPzogUmVxdWVzdE9wdGlvbnMpOiBQcm9taXNlPFQ+IHtcbiAgICByZXR1cm4gdGhpcy5tYWtlUmVxdWVzdDxUPihlbmRwb2ludCwgeyAuLi5vcHRpb25zLCBtZXRob2Q6ICdHRVQnIH0pXG4gIH1cblxuICBhc3luYyBwb3N0PFQ+KGVuZHBvaW50OiBzdHJpbmcsIGJvZHk/OiBhbnksIG9wdGlvbnM/OiBSZXF1ZXN0T3B0aW9ucyk6IFByb21pc2U8VD4ge1xuICAgIHJldHVybiB0aGlzLm1ha2VSZXF1ZXN0PFQ+KGVuZHBvaW50LCB7IC4uLm9wdGlvbnMsIG1ldGhvZDogJ1BPU1QnLCBib2R5IH0pXG4gIH1cblxuICBhc3luYyBwdXQ8VD4oZW5kcG9pbnQ6IHN0cmluZywgYm9keT86IGFueSwgb3B0aW9ucz86IFJlcXVlc3RPcHRpb25zKTogUHJvbWlzZTxUPiB7XG4gICAgcmV0dXJuIHRoaXMubWFrZVJlcXVlc3Q8VD4oZW5kcG9pbnQsIHsgLi4ub3B0aW9ucywgbWV0aG9kOiAnUFVUJywgYm9keSB9KVxuICB9XG5cbiAgYXN5bmMgZGVsZXRlPFQ+KGVuZHBvaW50OiBzdHJpbmcsIG9wdGlvbnM/OiBSZXF1ZXN0T3B0aW9ucyk6IFByb21pc2U8VD4ge1xuICAgIHJldHVybiB0aGlzLm1ha2VSZXF1ZXN0PFQ+KGVuZHBvaW50LCB7IC4uLm9wdGlvbnMsIG1ldGhvZDogJ0RFTEVURScgfSlcbiAgfVxuXG4gIGFzeW5jIHBhdGNoPFQ+KGVuZHBvaW50OiBzdHJpbmcsIGJvZHk/OiBhbnksIG9wdGlvbnM/OiBSZXF1ZXN0T3B0aW9ucyk6IFByb21pc2U8VD4ge1xuICAgIHJldHVybiB0aGlzLm1ha2VSZXF1ZXN0PFQ+KGVuZHBvaW50LCB7IC4uLm9wdGlvbnMsIG1ldGhvZDogJ1BBVENIJywgYm9keSB9KVxuICB9XG5cbiAgLy8gQ2xlYXIgY2FjaGVcbiAgY2xlYXJDYWNoZSgpOiB2b2lkIHtcbiAgICB0aGlzLmNhY2hlLmNsZWFyKClcbiAgfVxuXG4gIC8vIFNldCBjYWNoZSBUVExcbiAgc2V0Q2FjaGVUVEwodHRsOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmNhY2hlVFRMID0gdHRsXG4gIH1cbn1cblxuLy8gVXNlciBpbnRlcmZhY2VcbmV4cG9ydCBpbnRlcmZhY2UgVXNlciB7XG4gIGlkOiBzdHJpbmdcbiAgZW1haWw6IHN0cmluZ1xuICB1c2VybmFtZTogc3RyaW5nXG4gIGRpc3BsYXlfbmFtZTogc3RyaW5nXG4gIGlzX2NyZWF0b3I6IGJvb2xlYW5cbiAgaXNfdmVyaWZpZWQ6IGJvb2xlYW5cbiAgYXZhdGFyX3VybD86IHN0cmluZ1xuICBiaW8/OiBzdHJpbmdcbiAgZm9sbG93ZXJzX2NvdW50OiBudW1iZXJcbiAgZm9sbG93aW5nX2NvdW50OiBudW1iZXJcbiAgcG9zdHNfY291bnQ6IG51bWJlclxuICBjcmVhdGVkX2F0OiBzdHJpbmdcbiAgdXBkYXRlZF9hdDogc3RyaW5nXG59XG5cbi8vIENyZWF0ZSBzaW5nbGV0b24gaW5zdGFuY2VcbmNvbnN0IGFwaUNsaWVudCA9IG5ldyBBcGlDbGllbnQoe1xuICBiYXNlVVJMOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfVVJMIHx8ICdodHRwOi8vbG9jYWxob3N0OjMwMDEvYXBpL3YxJyxcbiAgdGltZW91dDogMTAwMDAsXG4gIHJldHJpZXM6IDMsXG4gIHJldHJ5RGVsYXk6IDEwMDBcbn0pXG5cbi8vIEFkZCBhdXRoZW50aWNhdGlvbiBtZXRob2RzIHRvIHRoZSBjbGllbnRcbmFwaUNsaWVudC5sb2dpbiA9IGFzeW5jIChlbWFpbDogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nKSA9PiB7XG4gIHJldHVybiBhcGlDbGllbnQucG9zdCgnL2F1dGgvbG9naW4nLCB7IGVtYWlsLCBwYXNzd29yZCB9KVxufVxuXG5hcGlDbGllbnQucmVnaXN0ZXIgPSBhc3luYyAodXNlckRhdGE6IGFueSkgPT4ge1xuICByZXR1cm4gYXBpQ2xpZW50LnBvc3QoJy9hdXRoL3JlZ2lzdGVyJywgdXNlckRhdGEpXG59XG5cbmFwaUNsaWVudC5sb2dvdXQgPSBhc3luYyAoKSA9PiB7XG4gIHJldHVybiBhcGlDbGllbnQucG9zdCgnL2F1dGgvbG9nb3V0Jylcbn1cblxuYXBpQ2xpZW50LmdldEN1cnJlbnRVc2VyID0gYXN5bmMgKCkgPT4ge1xuICByZXR1cm4gYXBpQ2xpZW50LmdldCgnL2F1dGgvbWUnKVxufVxuXG5leHBvcnQgZGVmYXVsdCBhcGlDbGllbnRcbmV4cG9ydCB7IEFwaUNsaWVudCB9Il0sIm5hbWVzIjpbIkFwaUNsaWVudCIsIm1ha2VSZXF1ZXN0IiwiZW5kcG9pbnQiLCJvcHRpb25zIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJ0aW1lb3V0IiwicmV0cmllcyIsInVybCIsImJhc2VVUkwiLCJjYWNoZUtleSIsIkpTT04iLCJzdHJpbmdpZnkiLCJjYWNoZWQiLCJjYWNoZSIsImdldCIsIkRhdGUiLCJub3ciLCJ0aW1lc3RhbXAiLCJjYWNoZVRUTCIsImRhdGEiLCJjb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwidGltZW91dElkIiwic2V0VGltZW91dCIsImFib3J0IiwicmVzcG9uc2UiLCJmZXRjaCIsInVuZGVmaW5lZCIsInNpZ25hbCIsImNsZWFyVGltZW91dCIsIm9rIiwiRXJyb3IiLCJzdGF0dXMiLCJzdGF0dXNUZXh0IiwianNvbiIsInNldCIsImVycm9yIiwic2hvdWxkUmV0cnkiLCJkZWxheSIsInJldHJ5RGVsYXkiLCJuYW1lIiwibWVzc2FnZSIsImluY2x1ZGVzIiwibXMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInBvc3QiLCJwdXQiLCJkZWxldGUiLCJwYXRjaCIsImNsZWFyQ2FjaGUiLCJjbGVhciIsInNldENhY2hlVFRMIiwidHRsIiwiY29uc3RydWN0b3IiLCJjb25maWciLCJNYXAiLCJhcGlDbGllbnQiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQVBJX1VSTCIsImxvZ2luIiwiZW1haWwiLCJwYXNzd29yZCIsInJlZ2lzdGVyIiwidXNlckRhdGEiLCJsb2dvdXQiLCJnZXRDdXJyZW50VXNlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/api-client.ts\n"));

/***/ })

});